
## 剑指offer
|  #   |                  名称                   |        分类         |
| :--: | :--------------------------------------: | :-----------------------: |
| 2 | 实现 Singleton | 设计模式 |
| 3 | 数组中重复的数字|[数组](./Solution3.java)|
| 4 | 二维数组中的查找| [数组](./Solution4.java)|
| 5 | 替换空格 | [字符串](./Solution5.java)|
| 6 | 从尾到头打印链表 | [链表](./Soluton6.java)|
| 7 | **重建二叉树** | [树](./Solution7.java)|
| 8 | 二叉树的下一个节点 | [树](./Solution8.java)|
| 9 | 用两个栈实现队列 | [栈、队列](./Solution9.java)|
| 10.1 | 斐波那契数列 | [动态规划、递归](./Solution10_1.java)|
| 10.2 | （变态）跳台阶 | [动态规划、递归](./Solution10_2.java)|
| 10.3 | 矩形覆盖 | [动态规划、递归](./Solution10_3.java)|
| 10.4 | **背包问题详解** | [动态规划、递归](./Solution10_4.java)|
| 11 | **旋转数组的最小数字** | [数组](./Solution11.java)|
| 12 | **矩阵中的路径** | [回溯](./Solution12.java)|
| 13 | **机器人的运动范围** | [回溯](./Solution13.java)|
| 14 | **剪绳子** | [动态规划、贪心算法](./Solution14.java)|
| 15 | **二进制中 1 的个数**，附[源码解析](https://blog.csdn.net/zhouzipeng000/article/details/56676885) | [位运算](./Solution15.java)|
| 16 | 数值的整数次方 | [递归](./Solution16.java)|
| 17 | 打印从 1 到最大的 n 位数 | [回溯](./Solution17.java)|
| 18.1 | 在 O(1) 时间内删除链表节点 | [链表](./Solution18_1.java)|
| 18.2 | 删除链表中重复的结点 | [链表,回溯](./Solution18_2.java)|
| 19 | **正则表达式匹配** | [递归，动态规划](./Solution19.java)|
| 20 | 表示数字的字符串 | [正则](./Solution20.java)|
| 21 | 调整数组顺序使奇数位于偶数前面 | [数组](./Solution21.java)|
| 22 | 链表中倒数第 K 个结点 | [链表，双指针](./Solution22.java)|
| 23 | **链表中环的入口结点** | [双指针](./Solution23.java)|
| 24 | **反转链表** | [递归，链表](./Solution24.java)|
| 25 | 合并两个排序的链表 | [链表，递归](./Solution25.java)|
| 26 | **树的子结构** | [递归，树](./Solution26.java)|
| 27 | 二叉树的镜像 | [树，递归](./Solution27.java)|
| 28 | 对称的二叉树 | [树，递归](./Solution28.java)|
| 29 | 顺时针打印矩阵 | [逻辑能力](./Solution29.java)|
| 30 | 包含 min 函数的栈 | [栈,类似9](./Solution30.java)|
| 31 | **栈的压入、弹出序** | [栈](./Solution31.java)|
| 32.1 | **从上往下打印二叉树** | [队列](./Solution32.java)|
| 32.2 | **分层打印二叉树** | [队列](./Solution32_2.java)|
| 32.3 | 之字形打印二叉树 | [队列](./Solution32_3.java)|
| 33 | 二叉搜索树的后序遍历序列 | [树的遍历，递归](./Solution33.java)|
| 34 | **二叉树中和为某一值的路径** | [树，递归](./Solution34.java)|
| 35 | **复杂链表的复制** | [复杂链表](./Solution35.java)|
| 36 | **二叉搜索树与双向链表** | [二叉树、链表](./Solution36.java)|
| 37 | **序列化二叉树** | [二叉树、递归](./Solution37.java)|
| 38 | **字符串的排列** | [回溯](./Solution38.java)|
| 39 | **数组中出现次数超过一半的数字** | [多数投票问题](./Solution39.java)|
| 40 | **最小的 K 个数** | [快排，大根堆小根堆](./Solution40.java)|
| 41.1 | 数据流中的中位数 | [大根堆小根堆](./Solution41_1.java)|
| 41.2 | 字符流中第一个不重复的字符 | [数据流](./Solution41_2.java)|
| 42 | 连续子数组的最大和 | [数组](./Solution42.java)|
| 43 | **从 1 到 n 整数中 1 出现的次数**，leetcode-233（Hard） | [逻辑](./Solution43.java)|
| 44 | 数字序列中的某一位数字 | [逻辑](./Solution44.java)|
| 45 | **把数组排成最小的数** | [排序，逻辑](./Solution45.java)|
| 46 | **把数字翻译成字符串** | [动态规划](./Solution46.java)|
| 47 | 礼物的最大价值 | [动态规划](./Solution47.java)|
| 48 | 最长不含重复字符的子字符串 | [双指针](./Solution48.java)|
| 49 | **丑数** | [动态规划，逻辑](./Solution49.java)|
| 50 | **第一个只出现一次的字符位置** | [BitSet](./Solution50.java)|
| 51 | **数组中的逆序对** | [排序问题](./Solution51.java)|
| 52 | **两个链表的第一个公共结点** | [链表，双指针](./Solution52.java)|
| 53 | **数字在排序数组中出现的次数** | [二分查找](./Solution53.java)|
| 54 | <font color="red">**二叉查找树的第 K 个结点**<font> | [二叉树，中序遍历](./Solution54.java)|
| 55.1 | 二叉树的深度 | [回溯](./Solution55_1.java)|
| 55.2 | 平衡二叉树 | [回溯](./Solution55_2.java)|
| 56 | **数组中只出现一次的数字** | [位运算](./Solution56.java)|
| 57.1 | 和为S的两个数字 | [数组，双指针](./Solution57_1.java)|
| 57.2 | 和为 S 的连续正数序列 | [数组，双指针](./Solution57_2.java)|
| 58.1 | 翻转单词顺序列 | [字符串](./Solution58_1.java)|
| 58.2 | 左旋转字符串 | [字符串](./Solution58_2.java)|
| 59 | 滑动窗口的最大值 | [大根堆，滑动窗口](./Solution59.java)|

## solution3. 数组中重复的数字
题目描述
在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

Input:
{2, 3, 1, 0, 2, 5}

Output:
2
## solution4. 二维数组中的查找
题目描述
在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.

## solution5. 替换空格
将一个字符串中的空格替换成 "%20"。

Input:
"We Are Happy"

Output:
"We%20Are%20Happy"

## solution6.从尾到头打印链表
输入链表的第一个节点，从尾到头反过来打印出每个结点的值。

## solution7.重建二叉树
根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历
和中序遍历的结果中都不含重复的数字。

## solution8.二叉树的下一个结点
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。
注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。
